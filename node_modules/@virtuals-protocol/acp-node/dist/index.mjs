var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@virtuals-protocol/acp-node",
      version: "0.3.0-beta.14",
      main: "./dist/index.js",
      module: "./dist/index.mjs",
      types: "./dist/index.d.ts",
      scripts: {
        test: "jest",
        "test:watch": "jest --watch",
        "test:coverage": "jest --coverage",
        tsup: "tsup src/index.ts --dts --format cjs,esm --out-dir dist"
      },
      author: "",
      license: "ISC",
      description: "",
      devDependencies: {
        "@babel/core": "^7.28.5",
        "@babel/preset-env": "^7.28.5",
        "@babel/preset-typescript": "^7.28.5",
        "@types/jest": "^30.0.0",
        "babel-jest": "^30.2.0",
        dotenv: "^17.2.3",
        jest: "^30.2.0",
        "ts-jest": "^29.4.5",
        typescript: "^5.8.3"
      },
      dependencies: {
        "@aa-sdk/core": "^4.73.0",
        "@account-kit/infra": "^4.73.0",
        "@account-kit/smart-contracts": "^4.73.0",
        "@virtuals-protocol/acp-node": "^0.3.0-beta.10",
        ajv: "^8.17.1",
        "socket.io-client": "^4.8.1",
        tsup: "^8.5.0",
        viem: "^2.28.2"
      },
      files: [
        "dist"
      ]
    };
  }
});

// src/abis/acpAbi.ts
var ACP_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "BudgetSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "evaluatorFee",
        type: "uint256"
      }
    ],
    name: "ClaimedEvaluatorFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "providerFee",
        type: "uint256"
      }
    ],
    name: "ClaimedProviderFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      }
    ],
    name: "JobCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymentToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "JobPaymentTokenSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint8",
        name: "oldPhase",
        type: "uint8"
      },
      { indexed: false, internalType: "uint8", name: "phase", type: "uint8" }
    ],
    name: "JobPhaseUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "isApproved",
        type: "bool"
      },
      {
        indexed: false,
        internalType: "string",
        name: "reason",
        type: "string"
      }
    ],
    name: "MemoSigned",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "string",
        name: "content",
        type: "string"
      }
    ],
    name: "NewMemo",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFeeCollected",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFeeRefunded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "payer",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "recipient",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "netAmount",
        type: "uint256"
      }
    ],
    name: "PayableFeeRequestExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "feeAmount",
        type: "uint256"
      }
    ],
    name: "PayableFundsEscrowed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableFundsRefunded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: false, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableRequestExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "memoId",
        type: "uint256"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: false, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "PayableTransferExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedAdditionalFees",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedBudget",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_COMPLETED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_EVALUATION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_EXPIRED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_NEGOTIATION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_REJECTED",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_REQUEST",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PHASE_TRANSACTION",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TOTAL_PHASES",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "X402_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" },
          { internalType: "uint8", name: "phase", type: "uint8" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "address", name: "evaluator", type: "address" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          }
        ],
        internalType: "struct ACPSimple.Job",
        name: "job",
        type: "tuple"
      }
    ],
    name: "canSign",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "id", type: "uint256" }],
    name: "claimBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "confirmX402PaymentReceived",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithX402",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      { internalType: "uint8", name: "nextPhase", type: "uint8" }
    ],
    name: "createMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      {
        internalType: "enum ACPSimple.FeeType",
        name: "feeType",
        type: "uint8"
      },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint8", name: "nextPhase", type: "uint8" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createPayableMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "evaluatorFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAllMemos",
    outputs: [
      {
        components: [
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum InteractionLedger.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "bool", name: "isSecured", type: "bool" },
          { internalType: "uint8", name: "nextPhase", type: "uint8" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" }
        ],
        internalType: "struct InteractionLedger.Memo[]",
        name: "",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" }
    ],
    name: "getJobPhaseMemoIds",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForPhase",
    outputs: [
      {
        components: [
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum InteractionLedger.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "bool", name: "isSecured", type: "bool" },
          { internalType: "uint8", name: "nextPhase", type: "uint8" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" }
        ],
        internalType: "struct InteractionLedger.Memo[]",
        name: "",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPhases",
    outputs: [{ internalType: "string[7]", name: "", type: "string[7]" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "paymentTokenAddress", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" },
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "isJobEvaluator",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "isPayableMemo",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "jobAdditionalFees",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "jobCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "jobMemoIds",
    outputs: [{ internalType: "uint256", name: "memoIds", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "jobs",
    outputs: [
      { internalType: "uint256", name: "id", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "uint256", name: "amountClaimed", type: "uint256" },
      { internalType: "uint8", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "memoCount", type: "uint256" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "memoCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "memoExpiredAt",
    outputs: [{ internalType: "uint256", name: "expiredAt", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "memos",
    outputs: [
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum InteractionLedger.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      { internalType: "uint8", name: "nextPhase", type: "uint8" },
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "sender", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "numEvaluatorsPerJob",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "payableDetails",
    outputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      {
        internalType: "enum ACPSimple.FeeType",
        name: "feeType",
        type: "uint8"
      },
      { internalType: "bool", name: "isExecuted", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformTreasury",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "setBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken_",
        type: "address"
      }
    ],
    name: "setBudgetWithPaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "bool", name: "isApproved", type: "bool" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "signMemo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "address", name: "signer", type: "address" }
    ],
    name: "signatories",
    outputs: [{ internalType: "uint8", name: "res", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updateEvaluatorFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" }
    ],
    name: "updatePlatformFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "memoId", type: "uint256" }],
    name: "withdrawEscrowedFunds",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "x402PaymentDetails",
    outputs: [
      { internalType: "bool", name: "isX402", type: "bool" },
      { internalType: "bool", name: "isBudgetReceived", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var acpAbi_default = ACP_ABI;

// src/acpClient.ts
import { zeroAddress as zeroAddress3 } from "viem";
import { io } from "socket.io-client";

// src/contractClients/baseAcpContractClient.ts
import {
  createPublicClient as createPublicClient2,
  encodeFunctionData,
  erc20Abi as erc20Abi2,
  http as http2,
  keccak256,
  toEventSignature,
  toHex,
  zeroAddress
} from "viem";

// src/configs/acpConfigs.ts
import { baseSepolia, base } from "@account-kit/infra";

// src/acpFare.ts
import {
  createPublicClient,
  erc20Abi,
  ethAddress,
  http,
  parseUnits
} from "viem";

// src/acpError.ts
var AcpError = class _AcpError extends Error {
  constructor(message, originalError) {
    super();
    this.message = message;
    this.name = "AcpError";
    if (originalError && typeof originalError === "object" && "stack" in originalError) {
      this.stack += `
Caused by: ${originalError.stack}`;
    }
    Object.setPrototypeOf(this, _AcpError.prototype);
  }
};
var acpError_default = AcpError;

// src/acpFare.ts
var Fare = class _Fare {
  constructor(contractAddress, decimals) {
    this.contractAddress = contractAddress;
    this.decimals = decimals;
  }
  formatAmount(amount) {
    return parseUnits(amount.toString(), this.decimals);
  }
  static async fromContractAddress(contractAddress, config = baseAcpConfig) {
    if (contractAddress === config.baseFare.contractAddress) {
      return config.baseFare;
    }
    const publicClient = createPublicClient({
      chain: config.chain,
      transport: http(config.rpcEndpoint)
    });
    const decimals = await publicClient.readContract({
      address: contractAddress,
      abi: erc20Abi,
      functionName: "decimals"
    });
    return new _Fare(contractAddress, decimals);
  }
};
var FareAmountBase = class {
  constructor(amount, fare) {
    this.amount = amount;
    this.fare = fare;
  }
  static async fromContractAddress(amount, contractAddress, config = baseAcpConfig) {
    const fare = await Fare.fromContractAddress(contractAddress, config);
    if (typeof amount === "number") {
      return new FareAmount(amount, fare);
    }
    return new FareBigInt(amount, fare);
  }
};
var FareAmount = class extends FareAmountBase {
  constructor(fareAmount, fare) {
    const truncateTo6Decimals = (input) => {
      const [intPart, decPart = ""] = input.split(".");
      if (decPart === "") {
        return parseFloat(intPart);
      }
      const truncated = decPart.slice(0, 6).padEnd(6, "0");
      return parseFloat(`${intPart}.${truncated}`);
    };
    super(fare.formatAmount(truncateTo6Decimals(fareAmount.toString())), fare);
  }
  add(other) {
    if (this.fare.contractAddress !== other.fare.contractAddress) {
      throw new Error("Token addresses do not match");
    }
    return new FareBigInt(this.amount + other.amount, this.fare);
  }
};
var FareBigInt = class _FareBigInt {
  constructor(amount, fare) {
    this.amount = amount;
    this.fare = fare;
  }
  add(other) {
    if (this.fare.contractAddress !== other.fare.contractAddress) {
      throw new acpError_default("Token addresses do not match");
    }
    return new _FareBigInt(this.amount + other.amount, this.fare);
  }
};
var wethFare = new Fare("0x4200000000000000000000000000000000000006", 18);
var ethFare = new Fare(ethAddress, 18);

// src/abis/acpAbiV2.ts
var ACP_V2_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  { inputs: [], name: "EnforcedPause", type: "error" },
  { inputs: [], name: "ExpectedPause", type: "error" },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      { indexed: false, internalType: "bool", name: "isActive", type: "bool" }
    ],
    name: "AccountStatusUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "evaluatorFee",
        type: "uint256"
      }
    ],
    name: "ClaimedEvaluatorFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "providerFee",
        type: "uint256"
      }
    ],
    name: "ClaimedProviderFee",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "string",
        name: "moduleType",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "oldModule",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newModule",
        type: "address"
      }
    ],
    name: "ModuleUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Paused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RefundedBudget",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Unpaused",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MODULE_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "OPERATOR_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "accountManager",
    outputs: [
      { internalType: "contract IAccountManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "jobId", type: "uint256" }
    ],
    name: "canSign",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "claimBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "bool", name: "isSecured", type: "bool" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "nextPhase",
        type: "uint8"
      }
    ],
    name: "createMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "string", name: "content", type: "string" },
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "recipient", type: "address" },
      { internalType: "uint256", name: "feeAmount", type: "uint256" },
      { internalType: "enum ACPTypes.FeeType", name: "feeType", type: "uint8" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "bool", name: "isSecured", type: "bool" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "nextPhase",
        type: "uint8"
      }
    ],
    name: "createPayableMemo",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "createX402Job",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createX402JobWithAccount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "defaultPaymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "emergencyWithdraw",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "evaluatorFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "accountId", type: "uint256" }],
    name: "getAccount",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "jobCount", type: "uint256" },
          {
            internalType: "uint256",
            name: "completedJobCount",
            type: "uint256"
          },
          { internalType: "bool", name: "isActive", type: "bool" }
        ],
        internalType: "struct ACPTypes.Account",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAllMemos",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      {
        internalType: "enum ACPTypes.MemoType",
        name: "memoType",
        type: "uint8"
      },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForMemoType",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "enum ACPTypes.JobPhase", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getMemosForPhaseType",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "jobId", type: "uint256" },
          { internalType: "address", name: "sender", type: "address" },
          { internalType: "string", name: "content", type: "string" },
          {
            internalType: "enum ACPTypes.MemoType",
            name: "memoType",
            type: "uint8"
          },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "bool", name: "isApproved", type: "bool" },
          { internalType: "address", name: "approvedBy", type: "address" },
          { internalType: "uint256", name: "approvedAt", type: "uint256" },
          { internalType: "bool", name: "requiresApproval", type: "bool" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "bool", name: "isSecured", type: "bool" },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "nextPhase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Memo[]",
        name: "memos",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getPhases",
    outputs: [{ internalType: "string[7]", name: "", type: "string[7]" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "defaultPaymentToken_",
        type: "address"
      },
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "isJobEvaluator",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "jobManager",
    outputs: [
      { internalType: "contract IJobManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "memoManager",
    outputs: [
      { internalType: "contract IMemoManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "paymentManager",
    outputs: [
      { internalType: "contract IPaymentManager", name: "", type: "address" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformFeeBP",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "platformTreasury",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "setBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "paymentToken", type: "address" }
    ],
    name: "setBudgetWithPaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "memoId", type: "uint256" },
      { internalType: "bool", name: "isApproved", type: "bool" },
      { internalType: "string", name: "reason", type: "string" }
    ],
    name: "signMemo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" }
    ],
    name: "updateAccountMetadata",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updateEvaluatorFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "moduleType", type: "string" },
      { internalType: "address", name: "moduleAddress", type: "address" }
    ],
    name: "updateModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "platformFeeBP_", type: "uint256" },
      { internalType: "address", name: "platformTreasury_", type: "address" },
      { internalType: "uint256", name: "evaluatorFeeBP_", type: "uint256" }
    ],
    name: "updatePlatformConfig",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
var acpAbiV2_default = ACP_V2_ABI;

// src/configs/acpConfigs.ts
var V1_MAX_RETRIES = 10;
var V2_MAX_RETRIES = 3;
var AcpContractConfig2 = class {
  constructor(chain, contractAddress, baseFare, alchemyRpcUrl, acpUrl, abi, maxRetries, rpcEndpoint, x402Config) {
    this.chain = chain;
    this.contractAddress = contractAddress;
    this.baseFare = baseFare;
    this.alchemyRpcUrl = alchemyRpcUrl;
    this.acpUrl = acpUrl;
    this.abi = abi;
    this.maxRetries = maxRetries;
    this.rpcEndpoint = rpcEndpoint;
    this.x402Config = x402Config;
  }
};
var baseSepoliaAcpConfig = new AcpContractConfig2(
  baseSepolia,
  "0x8Db6B1c839Fc8f6bd35777E194677B67b4D51928",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  void 0
);
var baseSepoliaAcpX402Config = new AcpContractConfig2(
  baseSepolia,
  "0x8Db6B1c839Fc8f6bd35777E194677B67b4D51928",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  {
    url: "https://dev-acp-x402.virtuals.io"
  }
);
var baseSepoliaAcpConfigV2 = new AcpContractConfig2(
  baseSepolia,
  "0xdf54E6Ed6cD1d0632d973ADECf96597b7e87893c",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  void 0
);
var baseSepoliaAcpX402ConfigV2 = new AcpContractConfig2(
  baseSepolia,
  "0xdf54E6Ed6cD1d0632d973ADECf96597b7e87893c",
  new Fare("0x036CbD53842c5426634e7929541eC2318f3dCF7e", 6),
  "https://alchemy-proxy.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.gg",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  {
    url: "https://dev-acp-x402.virtuals.io"
  }
);
var baseAcpConfig = new AcpContractConfig2(
  base,
  "0x6a1FE26D54ab0d3E1e3168f2e0c0cDa5cC0A0A4A",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  void 0
);
var baseAcpX402Config = new AcpContractConfig2(
  base,
  "0x6a1FE26D54ab0d3E1e3168f2e0c0cDa5cC0A0A4A",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbi_default,
  V1_MAX_RETRIES,
  void 0,
  {
    url: "https://acp-x402.virtuals.io"
  }
);
var baseAcpConfigV2 = new AcpContractConfig2(
  base,
  "0xa6C9BA866992cfD7fd6460ba912bfa405adA9df0",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  void 0
);
var baseAcpX402ConfigV2 = new AcpContractConfig2(
  base,
  "0xa6C9BA866992cfD7fd6460ba912bfa405adA9df0",
  new Fare("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", 6),
  "https://alchemy-proxy-prod.virtuals.io/api/proxy/rpc",
  "https://acpx.virtuals.io",
  acpAbiV2_default,
  V2_MAX_RETRIES,
  void 0,
  {
    url: "https://acp-x402.virtuals.io"
  }
);

// src/abis/wethAbi.ts
var WETH_ABI = [
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: true, internalType: "address", name: "guy", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "dst", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Deposit",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: true, internalType: "address", name: "dst", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "src", type: "address" },
      { indexed: false, internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "Withdrawal",
    type: "event"
  },
  { payable: true, stateMutability: "payable", type: "fallback" },
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "guy", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "deposit",
    outputs: [],
    payable: true,
    stateMutability: "payable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      { internalType: "address", name: "src", type: "address" },
      { internalType: "address", name: "dst", type: "address" },
      { internalType: "uint256", name: "wad", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [{ internalType: "uint256", name: "wad", type: "uint256" }],
    name: "withdraw",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
var wethAbi_default = WETH_ABI;

// src/abis/fiatTokenV2Abi.ts
var FIAT_TOKEN_V2_ABI = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "nonce",
        type: "bytes32"
      }
    ],
    name: "AuthorizationCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "authorizer",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "nonce",
        type: "bytes32"
      }
    ],
    name: "AuthorizationUsed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "Blacklisted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newBlacklister",
        type: "address"
      }
    ],
    name: "BlacklisterChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "burner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newMasterMinter",
        type: "address"
      }
    ],
    name: "MasterMinterChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "minter",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "minter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "minterAllowedAmount",
        type: "uint256"
      }
    ],
    name: "MinterConfigured",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "oldMinter",
        type: "address"
      }
    ],
    name: "MinterRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "Pause", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newAddress",
        type: "address"
      }
    ],
    name: "PauserChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "newRescuer",
        type: "address"
      }
    ],
    name: "RescuerChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "UnBlacklisted",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "Unpause", type: "event" },
  {
    inputs: [],
    name: "CANCEL_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "RECEIVE_WITH_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "TRANSFER_WITH_AUTHORIZATION_TYPEHASH",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" }
    ],
    name: "authorizationState",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "blacklist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "blacklister",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "cancelAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "authorizer", type: "address" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "cancelAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "minter", type: "address" },
      { internalType: "uint256", name: "minterAllowedAmount", type: "uint256" }
    ],
    name: "configureMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "currency",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "decrement", type: "uint256" }
    ],
    name: "decreaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "increment", type: "uint256" }
    ],
    name: "increaseAllowance",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "tokenName", type: "string" },
      { internalType: "string", name: "tokenSymbol", type: "string" },
      { internalType: "string", name: "tokenCurrency", type: "string" },
      { internalType: "uint8", name: "tokenDecimals", type: "uint8" },
      { internalType: "address", name: "newMasterMinter", type: "address" },
      { internalType: "address", name: "newPauser", type: "address" },
      { internalType: "address", name: "newBlacklister", type: "address" },
      { internalType: "address", name: "newOwner", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "string", name: "newName", type: "string" }],
    name: "initializeV2",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "lostAndFound", type: "address" }
    ],
    name: "initializeV2_1",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accountsToBlacklist",
        type: "address[]"
      },
      { internalType: "string", name: "newSymbol", type: "string" }
    ],
    name: "initializeV2_2",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "isBlacklisted",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "isMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "masterMinter",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_to", type: "address" },
      { internalType: "uint256", name: "_amount", type: "uint256" }
    ],
    name: "mint",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "minter", type: "address" }],
    name: "minterAllowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "nonces",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "paused",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pauser",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "receiveWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "receiveWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "minter", type: "address" }],
    name: "removeMinter",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IERC20",
        name: "tokenContract",
        type: "address"
      },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "rescueERC20",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "rescuer",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "uint256", name: "validAfter", type: "uint256" },
      { internalType: "uint256", name: "validBefore", type: "uint256" },
      { internalType: "bytes32", name: "nonce", type: "bytes32" },
      { internalType: "uint8", name: "v", type: "uint8" },
      { internalType: "bytes32", name: "r", type: "bytes32" },
      { internalType: "bytes32", name: "s", type: "bytes32" }
    ],
    name: "transferWithAuthorization",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_account", type: "address" }],
    name: "unBlacklist",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unpause",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_newBlacklister", type: "address" }
    ],
    name: "updateBlacklister",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "_newMasterMinter", type: "address" }
    ],
    name: "updateMasterMinter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "_newPauser", type: "address" }],
    name: "updatePauser",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newRescuer", type: "address" }],
    name: "updateRescuer",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];
var fiatTokenV2Abi_default = FIAT_TOKEN_V2_ABI;

// src/abis/singleSignerValidationModuleAbi.ts
var SINGLE_SIGNER_VALIDATION_MODULE_ABI = [
  { inputs: [], name: "InvalidSignatureType", type: "error" },
  {
    inputs: [],
    name: "NotAuthorized",
    type: "error"
  },
  { inputs: [], name: "NotImplemented", type: "error" },
  {
    inputs: [],
    name: "UnexpectedDataPassed",
    type: "error"
  },
  {
    anonymous: true,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint32",
        name: "entityId",
        type: "uint32"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newSigner",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "previousSigner",
        type: "address"
      }
    ],
    name: "SignerTransferred",
    type: "event"
  },
  {
    inputs: [],
    name: "moduleId",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "onInstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
    name: "onUninstall",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        internalType: "bytes32",
        name: "hash",
        type: "bytes32"
      }
    ],
    name: "replaySafeHash",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint32", name: "entityId", type: "uint32" },
      {
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "signers",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint32", name: "entityId", type: "uint32" },
      {
        internalType: "address",
        name: "newSigner",
        type: "address"
      }
    ],
    name: "transferSigner",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        internalType: "uint32",
        name: "entityId",
        type: "uint32"
      },
      { internalType: "address", name: "sender", type: "address" },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      { internalType: "bytes", name: "", type: "bytes" },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    name: "validateRuntime",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      {
        internalType: "uint32",
        name: "entityId",
        type: "uint32"
      },
      { internalType: "address", name: "", type: "address" },
      {
        internalType: "bytes32",
        name: "digest",
        type: "bytes32"
      },
      { internalType: "bytes", name: "signature", type: "bytes" }
    ],
    name: "validateSignature",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint32",
        name: "entityId",
        type: "uint32"
      },
      {
        components: [
          { internalType: "address", name: "sender", type: "address" },
          {
            internalType: "uint256",
            name: "nonce",
            type: "uint256"
          },
          { internalType: "bytes", name: "initCode", type: "bytes" },
          {
            internalType: "bytes",
            name: "callData",
            type: "bytes"
          },
          {
            internalType: "bytes32",
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "preVerificationGas",
            type: "uint256"
          },
          { internalType: "bytes32", name: "gasFees", type: "bytes32" },
          {
            internalType: "bytes",
            name: "paymasterAndData",
            type: "bytes"
          },
          { internalType: "bytes", name: "signature", type: "bytes" }
        ],
        internalType: "struct PackedUserOperation",
        name: "userOp",
        type: "tuple"
      },
      { internalType: "bytes32", name: "userOpHash", type: "bytes32" }
    ],
    name: "validateUserOp",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  }
];
var singleSignerValidationModuleAbi_default = SINGLE_SIGNER_VALIDATION_MODULE_ABI;

// src/constants.ts
import { base as base2, baseSepolia as baseSepolia2 } from "viem/chains";
var USDC_TOKEN_ADDRESS = {
  [baseSepolia2.id]: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
  [base2.id]: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913"
};
var X402AuthorizationTypes = [
  { name: "from", type: "address" },
  { name: "to", type: "address" },
  { name: "value", type: "uint256" },
  { name: "validAfter", type: "uint256" },
  { name: "validBefore", type: "uint256" },
  { name: "nonce", type: "bytes32" }
];
var HTTP_STATUS_CODES = {
  OK: 200,
  PAYMENT_REQUIRED: 402
};
var SINGLE_SIGNER_VALIDATION_MODULE_ADDRESS = "0x00000000000099DE0BF6fA90dEB851E2A2df7d83";

// src/contractClients/baseAcpContractClient.ts
var MemoType = /* @__PURE__ */ ((MemoType3) => {
  MemoType3[MemoType3["MESSAGE"] = 0] = "MESSAGE";
  MemoType3[MemoType3["CONTEXT_URL"] = 1] = "CONTEXT_URL";
  MemoType3[MemoType3["IMAGE_URL"] = 2] = "IMAGE_URL";
  MemoType3[MemoType3["VOICE_URL"] = 3] = "VOICE_URL";
  MemoType3[MemoType3["OBJECT_URL"] = 4] = "OBJECT_URL";
  MemoType3[MemoType3["TXHASH"] = 5] = "TXHASH";
  MemoType3[MemoType3["PAYABLE_REQUEST"] = 6] = "PAYABLE_REQUEST";
  MemoType3[MemoType3["PAYABLE_TRANSFER"] = 7] = "PAYABLE_TRANSFER";
  MemoType3[MemoType3["PAYABLE_TRANSFER_ESCROW"] = 8] = "PAYABLE_TRANSFER_ESCROW";
  MemoType3[MemoType3["NOTIFICATION"] = 9] = "NOTIFICATION";
  MemoType3[MemoType3["PAYABLE_NOTIFICATION"] = 10] = "PAYABLE_NOTIFICATION";
  return MemoType3;
})(MemoType || {});
var AcpJobPhases = /* @__PURE__ */ ((AcpJobPhases3) => {
  AcpJobPhases3[AcpJobPhases3["REQUEST"] = 0] = "REQUEST";
  AcpJobPhases3[AcpJobPhases3["NEGOTIATION"] = 1] = "NEGOTIATION";
  AcpJobPhases3[AcpJobPhases3["TRANSACTION"] = 2] = "TRANSACTION";
  AcpJobPhases3[AcpJobPhases3["EVALUATION"] = 3] = "EVALUATION";
  AcpJobPhases3[AcpJobPhases3["COMPLETED"] = 4] = "COMPLETED";
  AcpJobPhases3[AcpJobPhases3["REJECTED"] = 5] = "REJECTED";
  AcpJobPhases3[AcpJobPhases3["EXPIRED"] = 6] = "EXPIRED";
  return AcpJobPhases3;
})(AcpJobPhases || {});
var BaseAcpContractClient = class {
  constructor(agentWalletAddress, config = baseAcpConfig) {
    this.agentWalletAddress = agentWalletAddress;
    this.config = config;
    this.chain = config.chain;
    this.abi = config.abi;
    this.contractAddress = config.contractAddress;
    const jobCreated = acpAbi_default.find(
      (abi) => abi.name === "JobCreated"
    );
    const signature = toEventSignature(jobCreated);
    this.jobCreatedSignature = keccak256(toHex(signature));
    this.publicClient = createPublicClient2({
      chain: this.chain,
      transport: http2(this.config.rpcEndpoint)
    });
  }
  async validateSessionKeyOnChain(sessionSignerAddress, sessionEntityKeyId) {
    const onChainSignerAddress = (await this.publicClient.readContract({
      address: SINGLE_SIGNER_VALIDATION_MODULE_ADDRESS,
      abi: singleSignerValidationModuleAbi_default,
      functionName: "signers",
      args: [sessionEntityKeyId, this.agentWalletAddress]
    })).toLowerCase();
    if (onChainSignerAddress === zeroAddress.toLowerCase()) {
      throw new acpError_default(
        `ACP Contract Client validation failed:
${JSON.stringify(
          {
            reason: "no whitelisted wallet registered on-chain for entity id",
            entityId: sessionEntityKeyId,
            agentWalletAddress: this.agentWalletAddress
          },
          null,
          2
        )}`
      );
    }
    if (onChainSignerAddress !== sessionSignerAddress.toLowerCase()) {
      throw new acpError_default(
        `ACP Contract Client validation failed:
${JSON.stringify(
          {
            agentWalletAddress: this.agentWalletAddress,
            entityId: sessionEntityKeyId,
            givenWhitelistedWalletAddress: sessionSignerAddress,
            expectedWhitelistedWalletAddress: onChainSignerAddress,
            reason: "session signer address mismatch"
          },
          null,
          2
        )}`
      );
    }
  }
  get walletAddress() {
    return this.agentWalletAddress;
  }
  createJobWithAccount(accountId, evaluatorAddress, budgetBaseUnit, paymentTokenAddress, expiredAt, isX402Job) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: isX402Job ? "createX402JobWithAccount" : "createJobWithAccount",
        args: [
          accountId,
          evaluatorAddress,
          budgetBaseUnit,
          paymentTokenAddress,
          Math.floor(expiredAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job with account", error);
    }
  }
  createJob(providerAddress, evaluatorAddress, expiredAt, paymentTokenAddress, budgetBaseUnit, metadata, isX402Job) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: isX402Job ? "createX402Job" : "createJob",
        args: [
          providerAddress,
          evaluatorAddress,
          Math.floor(expiredAt.getTime() / 1e3),
          paymentTokenAddress,
          budgetBaseUnit,
          metadata
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job", error);
    }
  }
  approveAllowance(amountBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    try {
      const data = encodeFunctionData({
        abi: erc20Abi2,
        functionName: "approve",
        args: [this.contractAddress, amountBaseUnit]
      });
      const payload = {
        data,
        contractAddress: paymentTokenAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to approve allowance", error);
    }
  }
  createPayableMemo(jobId, content, amountBaseUnit, recipient, feeAmountBaseUnit, feeType, nextPhase, type, expiredAt, token = this.config.baseFare.contractAddress, secured = true) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "createPayableMemo",
        args: [
          jobId,
          content,
          token,
          amountBaseUnit,
          recipient,
          feeAmountBaseUnit,
          feeType,
          type,
          Math.floor(expiredAt.getTime() / 1e3),
          secured,
          nextPhase
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create payable memo", error);
    }
  }
  createMemo(jobId, content, type, isSecured, nextPhase) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "createMemo",
        args: [jobId, content, type, isSecured, nextPhase]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create memo", error);
    }
  }
  signMemo(memoId, isApproved, reason) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "signMemo",
        args: [memoId, isApproved, reason]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to sign memo", error);
    }
  }
  setBudgetWithPaymentToken(jobId, budgetBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    return void 0;
  }
  updateAccountMetadata(accountId, metadata) {
    try {
      const data = encodeFunctionData({
        abi: this.abi,
        functionName: "updateAccountMetadata",
        args: [accountId, metadata]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to update account metadata", error);
    }
  }
  wrapEth(amountBaseUnit) {
    try {
      const data = encodeFunctionData({
        abi: wethAbi_default,
        functionName: "deposit"
      });
      const payload = {
        data,
        contractAddress: wethFare.contractAddress,
        value: amountBaseUnit
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to wrap eth", error);
    }
  }
  async getX402PaymentDetails(jobId) {
    try {
      const result = await this.publicClient.readContract({
        address: this.contractAddress,
        abi: this.abi,
        functionName: "x402PaymentDetails",
        args: [BigInt(jobId)]
      });
      return {
        isX402: result[0],
        isBudgetReceived: result[1]
      };
    } catch (error) {
      throw new acpError_default("Failed to get X402 payment details", error);
    }
  }
  async submitTransferWithAuthorization(from, to, value, validAfter, validBefore, nonce, signature) {
    try {
      const operations = [];
      const data = encodeFunctionData({
        abi: fiatTokenV2Abi_default,
        functionName: "transferWithAuthorization",
        args: [from, to, value, validAfter, validBefore, nonce, signature]
      });
      const payload = {
        data,
        contractAddress: this.config.baseFare.contractAddress
      };
      operations.push(payload);
      return operations;
    } catch (error) {
      throw new acpError_default("Failed to submit TransferWithAuthorization", error);
    }
  }
};
var baseAcpContractClient_default = BaseAcpContractClient;

// src/interfaces.ts
var AcpMemoStatus = /* @__PURE__ */ ((AcpMemoStatus2) => {
  AcpMemoStatus2["PENDING"] = "PENDING";
  AcpMemoStatus2["APPROVED"] = "APPROVED";
  AcpMemoStatus2["REJECTED"] = "REJECTED";
  return AcpMemoStatus2;
})(AcpMemoStatus || {});
var AcpAgentSort = /* @__PURE__ */ ((AcpAgentSort2) => {
  AcpAgentSort2["SUCCESSFUL_JOB_COUNT"] = "successfulJobCount";
  AcpAgentSort2["SUCCESS_RATE"] = "successRate";
  AcpAgentSort2["UNIQUE_BUYER_COUNT"] = "uniqueBuyerCount";
  AcpAgentSort2["MINS_FROM_LAST_ONLINE"] = "minsFromLastOnlineTime";
  return AcpAgentSort2;
})(AcpAgentSort || {});
var AcpGraduationStatus = /* @__PURE__ */ ((AcpGraduationStatus2) => {
  AcpGraduationStatus2["ALL"] = "all";
  AcpGraduationStatus2["GRADUATED"] = "graduated";
  AcpGraduationStatus2["NOT_GRADUATED"] = "not_graduated";
  return AcpGraduationStatus2;
})(AcpGraduationStatus || {});
var AcpOnlineStatus = /* @__PURE__ */ ((AcpOnlineStatus2) => {
  AcpOnlineStatus2["ALL"] = "all";
  AcpOnlineStatus2["ONLINE"] = "online";
  AcpOnlineStatus2["OFFLINE"] = "offline";
  return AcpOnlineStatus2;
})(AcpOnlineStatus || {});
var PayloadType = /* @__PURE__ */ ((PayloadType2) => {
  PayloadType2["FUND_RESPONSE"] = "fund_response";
  PayloadType2["OPEN_POSITION"] = "open_position";
  PayloadType2["SWAP_TOKEN"] = "swap_token";
  PayloadType2["RESPONSE_SWAP_TOKEN"] = "response_swap_token";
  PayloadType2["CLOSE_PARTIAL_POSITION"] = "close_partial_position";
  PayloadType2["CLOSE_POSITION"] = "close_position";
  PayloadType2["POSITION_FULFILLED"] = "position_fulfilled";
  PayloadType2["CLOSE_JOB_AND_WITHDRAW"] = "close_job_and_withdraw";
  PayloadType2["UNFULFILLED_POSITION"] = "unfulfilled_position";
  return PayloadType2;
})(PayloadType || {});
var PositionDirection = /* @__PURE__ */ ((PositionDirection2) => {
  PositionDirection2["LONG"] = "long";
  PositionDirection2["SHORT"] = "short";
  return PositionDirection2;
})(PositionDirection || {});

// src/utils.ts
function tryParseJson(content) {
  try {
    return JSON.parse(content);
  } catch (error) {
    return null;
  }
}
function preparePayload(payload) {
  return typeof payload === "string" ? payload : JSON.stringify(payload);
}
function safeBase64Encode(data) {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return globalThis.btoa(data);
  }
  return Buffer.from(data).toString("base64");
}

// src/acpJobOffering.ts
import { zeroAddress as zeroAddress2 } from "viem";
import Ajv from "ajv";
var AcpJobOffering = class {
  constructor(acpClient, acpContractClient, providerAddress, name, price, priceType = "fixed" /* FIXED */, requirement) {
    this.acpClient = acpClient;
    this.acpContractClient = acpContractClient;
    this.providerAddress = providerAddress;
    this.name = name;
    this.price = price;
    this.priceType = priceType;
    this.requirement = requirement;
    this.ajv = new Ajv({ allErrors: true });
  }
  async initiateJob(serviceRequirement, evaluatorAddress, expiredAt = new Date(Date.now() + 1e3 * 60 * 60 * 24)) {
    if (this.requirement && typeof this.requirement === "object") {
      const validator = this.ajv.compile(this.requirement);
      const valid = validator(serviceRequirement);
      if (!valid) {
        throw new acpError_default(this.ajv.errorsText(validator.errors));
      }
    }
    const finalServiceRequirement = {
      name: this.name,
      requirement: serviceRequirement,
      priceValue: this.price,
      priceType: this.priceType
    };
    const fareAmount = new FareAmount(
      this.priceType === "fixed" /* FIXED */ ? this.price : 0,
      this.acpContractClient.config.baseFare
    );
    const account = await this.acpClient.getByClientAndProvider(
      this.acpContractClient.walletAddress,
      this.providerAddress,
      this.acpContractClient
    );
    const isV1 = [
      baseSepoliaAcpConfig.contractAddress,
      baseSepoliaAcpX402Config.contractAddress,
      baseAcpConfig.contractAddress,
      baseAcpX402Config.contractAddress
    ].includes(this.acpContractClient.config.contractAddress);
    let createJobPayload;
    const chainId = this.acpContractClient.config.chain.id;
    const isUsdcPaymentToken = USDC_TOKEN_ADDRESS[chainId].toLowerCase() === fareAmount.fare.contractAddress.toLowerCase();
    const isX402Job = this.acpContractClient.config.x402Config && isUsdcPaymentToken;
    if (isV1 || !account) {
      createJobPayload = this.acpContractClient.createJob(
        this.providerAddress,
        evaluatorAddress || this.acpContractClient.walletAddress,
        expiredAt,
        fareAmount.fare.contractAddress,
        fareAmount.amount,
        "",
        isX402Job
      );
    } else {
      createJobPayload = this.acpContractClient.createJobWithAccount(
        account.id,
        evaluatorAddress || zeroAddress2,
        fareAmount.amount,
        fareAmount.fare.contractAddress,
        expiredAt,
        isX402Job
      );
    }
    const { userOpHash } = await this.acpContractClient.handleOperation([
      createJobPayload
    ]);
    const jobId = await this.acpContractClient.getJobId(
      userOpHash,
      this.acpContractClient.walletAddress,
      this.providerAddress
    );
    const payloads = [];
    const setBudgetWithPaymentTokenPayload = this.acpContractClient.setBudgetWithPaymentToken(
      jobId,
      fareAmount.amount,
      fareAmount.fare.contractAddress
    );
    if (setBudgetWithPaymentTokenPayload) {
      payloads.push(setBudgetWithPaymentTokenPayload);
    }
    payloads.push(
      this.acpContractClient.createMemo(
        jobId,
        JSON.stringify(finalServiceRequirement),
        0 /* MESSAGE */,
        true,
        1 /* NEGOTIATION */
      )
    );
    await this.acpContractClient.handleOperation(payloads);
    return jobId;
  }
};
var acpJobOffering_default = AcpJobOffering;

// src/acpJob.ts
var AcpJob = class {
  constructor(acpClient, id, clientAddress, providerAddress, evaluatorAddress, price, priceTokenAddress, memos, phase, context, contractAddress, netPayableAmount) {
    this.acpClient = acpClient;
    this.id = id;
    this.clientAddress = clientAddress;
    this.providerAddress = providerAddress;
    this.evaluatorAddress = evaluatorAddress;
    this.price = price;
    this.priceTokenAddress = priceTokenAddress;
    this.memos = memos;
    this.phase = phase;
    this.context = context;
    this.contractAddress = contractAddress;
    this.netPayableAmount = netPayableAmount;
    this.priceType = "fixed" /* FIXED */;
    this.priceValue = 0;
    const content = this.memos.find(
      (m) => m.nextPhase === 1 /* NEGOTIATION */
    )?.content;
    if (!content) {
      return;
    }
    const contentObj = tryParseJson(content);
    if (!contentObj) {
      return;
    }
    if (contentObj.serviceRequirement || contentObj.requirement) {
      this.requirement = contentObj.requirement || contentObj.serviceRequirement;
    }
    if (contentObj.serviceName || contentObj.name) {
      this.name = contentObj.name || contentObj.serviceName;
    }
    if (contentObj.priceType) {
      this.priceType = contentObj.priceType || "fixed" /* FIXED */;
    }
    if (contentObj.priceValue) {
      this.priceValue = contentObj.priceValue || this.price;
    }
  }
  get acpContractClient() {
    return this.acpClient.contractClientByAddress(this.contractAddress);
  }
  get config() {
    return this.acpContractClient.config;
  }
  get baseFare() {
    return this.acpContractClient.config.baseFare;
  }
  get deliverable() {
    return this.memos.find((m) => m.nextPhase === 4 /* COMPLETED */)?.content;
  }
  get rejectionReason() {
    const requestMemo = this.memos.find(
      (m) => m.nextPhase === 1 /* NEGOTIATION */ && m.status === "REJECTED" /* REJECTED */
    );
    if (requestMemo) {
      return requestMemo.signedReason;
    }
    return this.memos.find((m) => m.nextPhase === 5 /* REJECTED */)?.content;
  }
  get providerAgent() {
    return this.acpClient.getAgent(this.providerAddress);
  }
  get clientAgent() {
    return this.acpClient.getAgent(this.clientAddress);
  }
  get evaluatorAgent() {
    return this.acpClient.getAgent(this.evaluatorAddress);
  }
  get account() {
    return this.acpClient.getAccountByJobId(this.id, this.acpContractClient);
  }
  get latestMemo() {
    return this.memos[this.memos.length - 1];
  }
  async createRequirement(content) {
    const operations = [];
    operations.push(
      this.acpContractClient.createMemo(
        this.id,
        content,
        0 /* MESSAGE */,
        true,
        2 /* TRANSACTION */
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async createPayableRequirement(content, type, amount, recipient, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
    const operations = [];
    if (type === 8 /* PAYABLE_TRANSFER_ESCROW */) {
      operations.push(
        this.acpContractClient.approveAllowance(
          amount.amount,
          amount.fare.contractAddress
        )
      );
    }
    const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
    const isPercentagePricing = this.priceType === "percentage" /* PERCENTAGE */;
    operations.push(
      this.acpContractClient.createPayableMemo(
        this.id,
        content,
        amount.amount,
        recipient,
        isPercentagePricing ? BigInt(Math.round(this.priceValue * 1e4)) : feeAmount.amount,
        isPercentagePricing ? 3 /* PERCENTAGE_FEE */ : 0 /* NO_FEE */,
        2 /* TRANSACTION */,
        type,
        expiredAt,
        amount.fare.contractAddress
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async payAndAcceptRequirement(reason) {
    const memo = this.memos.find(
      (m) => m.nextPhase === 2 /* TRANSACTION */
    );
    if (!memo) {
      throw new acpError_default("No notification memo found");
    }
    const operations = [];
    const baseFareAmount = new FareAmount(this.price, this.baseFare);
    const transferAmount = memo.payableDetails ? await FareAmountBase.fromContractAddress(
      memo.payableDetails.amount,
      memo.payableDetails.token,
      this.config
    ) : new FareAmount(0, this.baseFare);
    const totalAmount = baseFareAmount.fare.contractAddress === transferAmount.fare.contractAddress ? baseFareAmount.add(transferAmount) : baseFareAmount;
    operations.push(
      this.acpContractClient.approveAllowance(
        totalAmount.amount,
        this.baseFare.contractAddress
      )
    );
    if (baseFareAmount.fare.contractAddress !== transferAmount.fare.contractAddress) {
      operations.push(
        this.acpContractClient.approveAllowance(
          transferAmount.amount,
          transferAmount.fare.contractAddress
        )
      );
    }
    operations.push(this.acpContractClient.signMemo(memo.id, true, reason));
    operations.push(
      this.acpContractClient.createMemo(
        this.id,
        `Payment made. ${reason ?? ""}`.trim(),
        0 /* MESSAGE */,
        true,
        3 /* EVALUATION */
      )
    );
    const x402PaymentDetails = await this.acpContractClient.getX402PaymentDetails(this.id);
    if (x402PaymentDetails.isX402) {
      await this.performX402Payment(this.price);
    }
    return await this.acpContractClient.handleOperation(operations);
  }
  async respond(accept, reason) {
    const memoContent = `${reason || `Job ${this.id} ${accept ? "accepted" : "rejected"}.`}`;
    if (accept) {
      await this.accept(memoContent);
      return this.createRequirement(memoContent);
    }
    return await this.reject(memoContent);
  }
  async accept(reason) {
    const memoContent = `Job ${this.id} accepted. ${reason || ""}`;
    const latestMemo = this.latestMemo;
    if (latestMemo?.nextPhase !== 1 /* NEGOTIATION */) {
      throw new acpError_default("No request memo found");
    }
    return await latestMemo.sign(true, memoContent);
  }
  async reject(reason) {
    const memoContent = `Job ${this.id} rejected. ${reason || ""}`;
    if (this.phase === 0 /* REQUEST */) {
      const latestMemo = this.latestMemo;
      if (latestMemo?.nextPhase !== 1 /* NEGOTIATION */) {
        throw new acpError_default("No request memo found");
      }
      return await latestMemo.sign(false, memoContent);
    }
    const operations = [];
    operations.push(
      this.acpContractClient.createMemo(
        this.id,
        memoContent,
        0 /* MESSAGE */,
        true,
        5 /* REJECTED */
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async rejectPayable(reason = "", amount, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
    const memoContent = `Job ${this.id} rejected. ${reason}`;
    const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
    const operations = [];
    operations.push(
      this.acpContractClient.approveAllowance(
        amount.amount,
        amount.fare.contractAddress
      )
    );
    operations.push(
      this.acpContractClient.createPayableMemo(
        this.id,
        memoContent,
        amount.amount,
        this.clientAddress,
        feeAmount.amount,
        0 /* NO_FEE */,
        5 /* REJECTED */,
        7 /* PAYABLE_TRANSFER */,
        expiredAt,
        amount.fare.contractAddress
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async deliver(deliverable) {
    if (this.latestMemo?.nextPhase !== 3 /* EVALUATION */) {
      throw new acpError_default("No transaction memo found");
    }
    const operations = [];
    operations.push(
      this.acpContractClient.createMemo(
        this.id,
        preparePayload(deliverable),
        0 /* MESSAGE */,
        true,
        4 /* COMPLETED */
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async deliverPayable(deliverable, amount, skipFee = false, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
    if (this.latestMemo?.nextPhase !== 3 /* EVALUATION */) {
      throw new acpError_default("No transaction memo found");
    }
    const operations = [];
    operations.push(
      this.acpContractClient.approveAllowance(
        amount.amount,
        amount.fare.contractAddress
      )
    );
    const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
    const isPercentagePricing = this.priceType === "percentage" /* PERCENTAGE */ && !skipFee;
    operations.push(
      this.acpContractClient.createPayableMemo(
        this.id,
        preparePayload(deliverable),
        amount.amount,
        this.clientAddress,
        isPercentagePricing ? BigInt(Math.round(this.priceValue * 1e4)) : feeAmount.amount,
        isPercentagePricing ? 3 /* PERCENTAGE_FEE */ : 0 /* NO_FEE */,
        4 /* COMPLETED */,
        7 /* PAYABLE_TRANSFER */,
        expiredAt,
        amount.fare.contractAddress
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async evaluate(accept, reason) {
    if (this.latestMemo?.nextPhase !== 4 /* COMPLETED */) {
      throw new acpError_default("No evaluation memo found");
    }
    const memo = this.latestMemo;
    await memo.sign(accept, reason);
  }
  async createNotification(content) {
    const operations = [];
    operations.push(
      this.acpContractClient.createMemo(
        this.id,
        content,
        9 /* NOTIFICATION */,
        true,
        4 /* COMPLETED */
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async createPayableNotification(content, amount, skipFee = false, expiredAt = new Date(Date.now() + 1e3 * 60 * 5)) {
    const operations = [];
    operations.push(
      this.acpContractClient.approveAllowance(
        amount.amount,
        amount.fare.contractAddress
      )
    );
    const feeAmount = new FareAmount(0, this.acpContractClient.config.baseFare);
    const isPercentagePricing = this.priceType === "percentage" /* PERCENTAGE */ && !skipFee;
    operations.push(
      this.acpContractClient.createPayableMemo(
        this.id,
        content,
        amount.amount,
        this.clientAddress,
        isPercentagePricing ? BigInt(Math.round(this.priceValue * 1e4)) : feeAmount.amount,
        isPercentagePricing ? 3 /* PERCENTAGE_FEE */ : 0 /* NO_FEE */,
        4 /* COMPLETED */,
        10 /* PAYABLE_NOTIFICATION */,
        expiredAt,
        amount.fare.contractAddress
      )
    );
    return await this.acpContractClient.handleOperation(operations);
  }
  async performX402Payment(budget) {
    const paymentUrl = "/acp-budget";
    const x402PayableREquirements = await this.acpContractClient.performX402Request(
      paymentUrl,
      this.acpContractClient.getAcpVersion(),
      budget.toString()
    );
    if (!x402PayableREquirements.isPaymentRequired) {
      return;
    }
    if (!x402PayableREquirements.data.accepts.length) {
      throw new acpError_default("No X402 payment requirements found");
    }
    const requirement = x402PayableREquirements.data.accepts[0];
    const { encodedPayment, signature, message } = await this.acpContractClient.generateX402Payment(
      {
        to: requirement.payTo,
        value: Number(requirement.maxAmountRequired),
        maxTimeoutSeconds: requirement.maxTimeoutSeconds,
        asset: requirement.asset
      },
      x402PayableREquirements.data
    );
    await this.acpContractClient.updateJobX402Nonce(this.id, message.nonce);
    const x402Response = await this.acpContractClient.performX402Request(
      paymentUrl,
      this.acpContractClient.getAcpVersion(),
      budget.toString(),
      encodedPayment
    );
    if (x402Response.isPaymentRequired) {
      const operations = await this.acpContractClient.submitTransferWithAuthorization(
        message.from,
        message.to,
        BigInt(message.value),
        BigInt(message.validAfter),
        BigInt(message.validBefore),
        message.nonce,
        signature
      );
      await this.acpContractClient.handleOperation(operations);
    }
    let waitMs = 2e3;
    const maxWaitMs = 3e4;
    let iterationCount = 0;
    const maxIterations = 10;
    while (true) {
      const x402PaymentDetails = await this.acpContractClient.getX402PaymentDetails(this.id);
      if (x402PaymentDetails.isBudgetReceived) {
        break;
      }
      iterationCount++;
      if (iterationCount >= maxIterations) {
        throw new acpError_default("X402 payment timed out");
      }
      await new Promise((resolve) => setTimeout(resolve, waitMs));
      waitMs = Math.min(waitMs * 2, maxWaitMs);
    }
  }
};
var acpJob_default = AcpJob;

// src/acpMemo.ts
var AcpMemo = class {
  constructor(contractClient, id, type, content, nextPhase, status, senderAddress, signedReason, expiry, payableDetails, txHash, signedTxHash) {
    this.contractClient = contractClient;
    this.id = id;
    this.type = type;
    this.content = content;
    this.nextPhase = nextPhase;
    this.status = status;
    this.senderAddress = senderAddress;
    this.signedReason = signedReason;
    this.expiry = expiry;
    this.payableDetails = payableDetails;
    this.txHash = txHash;
    this.signedTxHash = signedTxHash;
    if (this.payableDetails) {
      this.payableDetails.amount = BigInt(this.payableDetails.amount);
      this.payableDetails.feeAmount = BigInt(this.payableDetails.feeAmount);
    }
    this.structuredContent = tryParseJson(this.content) || void 0;
  }
  get payloadType() {
    return this.structuredContent?.type;
  }
  getStructuredContent() {
    return this.structuredContent;
  }
  async create(jobId, isSecured = true) {
    return await this.contractClient.createMemo(
      jobId,
      this.content,
      this.type,
      isSecured,
      this.nextPhase
    );
  }
  async sign(approved, reason) {
    const payload = this.contractClient.signMemo(this.id, approved, reason);
    return await this.contractClient.handleOperation([payload]);
  }
};
var acpMemo_default = AcpMemo;

// src/acpAccount.ts
var AcpAccount = class {
  constructor(contractClient, id, clientAddress, providerAddress, metadata) {
    this.contractClient = contractClient;
    this.id = id;
    this.clientAddress = clientAddress;
    this.providerAddress = providerAddress;
    this.metadata = metadata;
  }
  async updateMetadata(metadata) {
    const hash = await this.contractClient.updateAccountMetadata(
      this.id,
      JSON.stringify(metadata)
    );
    return hash;
  }
};

// src/acpClient.ts
var { version } = require_package();
var AcpClient = class {
  constructor(options) {
    this.contractClients = Array.isArray(options.acpContractClient) ? options.acpContractClient : [options.acpContractClient];
    if (this.contractClients.length === 0) {
      throw new acpError_default("ACP contract client is required");
    }
    this.contractClients.every((client) => {
      if (client.contractAddress !== this.contractClients[0].contractAddress) {
        throw new acpError_default(
          "All contract clients must have the same agent wallet address"
        );
      }
    });
    this.onNewTask = options.onNewTask;
    this.onEvaluate = options.onEvaluate || this.defaultOnEvaluate;
    this.init();
  }
  contractClientByAddress(address) {
    if (!address) {
      return this.contractClients[0];
    }
    const result = this.contractClients.find(
      (client) => client.contractAddress === address
    );
    if (!result) {
      throw new acpError_default("ACP contract client not found");
    }
    return result;
  }
  get acpContractClient() {
    return this.contractClients[0];
  }
  get acpUrl() {
    return this.acpContractClient.config.acpUrl;
  }
  async defaultOnEvaluate(job) {
    await job.evaluate(true, "Evaluated by default");
  }
  get walletAddress() {
    if (Array.isArray(this.acpContractClient)) {
      return this.acpContractClient[0].walletAddress;
    }
    return this.acpContractClient.walletAddress;
  }
  async init() {
    const socket = io(this.acpUrl, {
      auth: {
        walletAddress: this.walletAddress
      },
      extraHeaders: {
        "x-sdk-version": version,
        "x-sdk-language": "node",
        "x-contract-address": this.contractClients[0].contractAddress
        // always prioritize the first client
      },
      transports: ["websocket"]
    });
    socket.on("roomJoined" /* ROOM_JOINED */, (_, callback) => {
      console.log("Joined ACP Room");
      callback(true);
    });
    socket.on(
      "onEvaluate" /* ON_EVALUATE */,
      async (data, callback) => {
        callback(true);
        if (this.onEvaluate) {
          const job = new acpJob_default(
            this,
            data.id,
            data.clientAddress,
            data.providerAddress,
            data.evaluatorAddress,
            data.price,
            data.priceTokenAddress,
            data.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(data.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            data.phase,
            data.context,
            data.contractAddress,
            data.netPayableAmount
          );
          this.onEvaluate(job);
        }
      }
    );
    socket.on(
      "onNewTask" /* ON_NEW_TASK */,
      async (data, callback) => {
        callback(true);
        if (this.onNewTask) {
          const job = new acpJob_default(
            this,
            data.id,
            data.clientAddress,
            data.providerAddress,
            data.evaluatorAddress,
            data.price,
            data.priceTokenAddress,
            data.memos.map((memo) => {
              return new acpMemo_default(
                this.contractClientByAddress(data.contractAddress),
                memo.id,
                memo.memoType,
                memo.content,
                memo.nextPhase,
                memo.status,
                memo.senderAddress,
                memo.signedReason,
                memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
                memo.payableDetails,
                memo.txHash,
                memo.signedTxHash
              );
            }),
            data.phase,
            data.context,
            data.contractAddress,
            data.netPayableAmount
          );
          this.onNewTask(
            job,
            job.memos.find((m) => m.id == data.memoToSign)
          );
        }
      }
    );
    const cleanup = async () => {
      if (socket) {
        socket.disconnect();
      }
      process.exit(0);
    };
    process.on("SIGINT", cleanup);
    process.on("SIGTERM", cleanup);
  }
  async browseAgents(keyword, options) {
    let { cluster, sort_by, top_k, graduationStatus, onlineStatus } = options;
    top_k = top_k ?? 5;
    let url = `${this.acpUrl}/api/agents/v4/search?search=${keyword}`;
    if (sort_by && sort_by.length > 0) {
      url += `&sortBy=${sort_by.map((s) => s).join(",")}`;
    }
    if (top_k) {
      url += `&top_k=${top_k}`;
    }
    if (this.walletAddress) {
      url += `&walletAddressesToExclude=${this.walletAddress}`;
    }
    if (cluster) {
      url += `&cluster=${cluster}`;
    }
    if (graduationStatus) {
      url += `&graduationStatus=${graduationStatus}`;
    }
    if (onlineStatus) {
      url += `&onlineStatus=${onlineStatus}`;
    }
    const response = await fetch(url);
    const data = await response.json();
    const availableContractClientAddresses = this.contractClients.map(
      (client) => client.contractAddress.toLowerCase()
    );
    return data.data.filter(
      (agent) => agent.walletAddress.toLowerCase() !== this.walletAddress.toLowerCase()
    ).filter(
      (agent) => availableContractClientAddresses.includes(
        agent.contractAddress.toLowerCase()
      )
    ).map((agent) => {
      const acpContractClient = this.contractClients.find(
        (client) => client.contractAddress.toLowerCase() === agent.contractAddress.toLowerCase()
      );
      if (!acpContractClient) {
        throw new acpError_default("ACP contract client not found");
      }
      return {
        id: agent.id,
        name: agent.name,
        description: agent.description,
        jobOfferings: agent.jobs.map((jobs) => {
          return new acpJobOffering_default(
            this,
            acpContractClient,
            agent.walletAddress,
            jobs.name,
            jobs.priceV2.value,
            jobs.priceV2.type,
            jobs.requirement
          );
        }),
        contractAddress: agent.contractAddress,
        twitterHandle: agent.twitterHandle,
        walletAddress: agent.walletAddress,
        metrics: agent.metrics,
        resource: agent.resources
      };
    });
  }
  async initiateJob(providerAddress, serviceRequirement, fareAmount, evaluatorAddress, expiredAt = new Date(Date.now() + 1e3 * 60 * 60 * 24)) {
    if (providerAddress === this.walletAddress) {
      throw new acpError_default(
        "Provider address cannot be the same as the client address"
      );
    }
    const account = await this.getByClientAndProvider(
      this.walletAddress,
      providerAddress,
      this.acpContractClient
    );
    const isV1 = [
      baseSepoliaAcpConfig.contractAddress,
      baseSepoliaAcpX402Config.contractAddress,
      baseAcpConfig.contractAddress,
      baseAcpX402Config.contractAddress
    ].includes(this.acpContractClient.config.contractAddress);
    const defaultEvaluatorAddress = isV1 && !evaluatorAddress ? this.walletAddress : zeroAddress3;
    const chainId = this.acpContractClient.config.chain.id;
    const isUsdcPaymentToken = USDC_TOKEN_ADDRESS[chainId].toLowerCase() === fareAmount.fare.contractAddress.toLowerCase();
    const isX402Job = this.acpContractClient.config.x402Config && isUsdcPaymentToken;
    const createJobPayload = isV1 || !account ? this.acpContractClient.createJob(
      providerAddress,
      evaluatorAddress || defaultEvaluatorAddress,
      expiredAt,
      fareAmount.fare.contractAddress,
      fareAmount.amount,
      "",
      isX402Job
    ) : this.acpContractClient.createJobWithAccount(
      account.id,
      evaluatorAddress || defaultEvaluatorAddress,
      fareAmount.amount,
      fareAmount.fare.contractAddress,
      expiredAt,
      isX402Job
    );
    const { userOpHash } = await this.acpContractClient.handleOperation([
      createJobPayload
    ]);
    const jobId = await this.acpContractClient.getJobId(
      userOpHash,
      this.walletAddress,
      providerAddress
    );
    const payloads = [];
    const setBudgetWithPaymentTokenPayload = this.acpContractClient.setBudgetWithPaymentToken(
      jobId,
      fareAmount.amount,
      fareAmount.fare.contractAddress
    );
    if (setBudgetWithPaymentTokenPayload) {
      payloads.push(setBudgetWithPaymentTokenPayload);
    }
    payloads.push(
      this.acpContractClient.createMemo(
        jobId,
        preparePayload(serviceRequirement),
        0 /* MESSAGE */,
        true,
        1 /* NEGOTIATION */
      )
    );
    await this.acpContractClient.handleOperation(payloads);
    return jobId;
  }
  async getActiveJobs(page = 1, pageSize = 10) {
    let url = `${this.acpUrl}/api/jobs/active?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      return data.data.map((job) => {
        return new acpJob_default(
          this,
          job.id,
          job.clientAddress,
          job.providerAddress,
          job.evaluatorAddress,
          job.price,
          job.priceTokenAddress,
          job.memos.map((memo) => {
            return new acpMemo_default(
              this.contractClientByAddress(job.contractAddress),
              memo.id,
              memo.memoType,
              memo.content,
              memo.nextPhase,
              memo.status,
              memo.senderAddress,
              memo.signedReason,
              memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
              memo.payableDetails,
              memo.txHash,
              memo.signedTxHash
            );
          }),
          job.phase,
          job.context,
          job.contractAddress,
          job.netPayableAmount
        );
      });
    } catch (error) {
      throw new acpError_default("Failed to get active jobs", error);
    }
  }
  async getPendingMemoJobs(page = 1, pageSize = 10) {
    let url = `${this.acpUrl}/api/jobs/pending-memos?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.acpContractClient.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      return data.data.map((job) => {
        return new acpJob_default(
          this,
          job.id,
          job.clientAddress,
          job.providerAddress,
          job.evaluatorAddress,
          job.price,
          job.priceTokenAddress,
          job.memos.map((memo) => {
            return new acpMemo_default(
              this.contractClientByAddress(job.contractAddress),
              memo.id,
              memo.memoType,
              memo.content,
              memo.nextPhase,
              memo.status,
              memo.senderAddress,
              memo.signedReason,
              memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
              typeof memo.payableDetails === "string" ? tryParseJson(memo.payableDetails) || void 0 : memo.payableDetails,
              memo.txHash,
              memo.signedTxHash
            );
          }),
          job.phase,
          job.context,
          job.contractAddress,
          job.netPayableAmount
        );
      });
    } catch (error) {
      throw new acpError_default("Failed to get pending memo jobs", error);
    }
  }
  async getCompletedJobs(page = 1, pageSize = 10) {
    let url = `${this.acpUrl}/api/jobs/completed?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.acpContractClient.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      return data.data.map((job) => {
        return new acpJob_default(
          this,
          job.id,
          job.clientAddress,
          job.providerAddress,
          job.evaluatorAddress,
          job.price,
          job.priceTokenAddress,
          job.memos.map((memo) => {
            return new acpMemo_default(
              this.contractClientByAddress(job.contractAddress),
              memo.id,
              memo.memoType,
              memo.content,
              memo.nextPhase,
              memo.status,
              memo.senderAddress,
              memo.signedReason,
              memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
              memo.payableDetails,
              memo.txHash,
              memo.signedTxHash
            );
          }),
          job.phase,
          job.context,
          job.contractAddress,
          job.netPayableAmount
        );
      });
    } catch (error) {
      throw new acpError_default("Failed to get completed jobs", error);
    }
  }
  async getCancelledJobs(page = 1, pageSize = 10) {
    let url = `${this.acpUrl}/api/jobs/cancelled?pagination[page]=${page}&pagination[pageSize]=${pageSize}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      return data.data.map((job) => {
        return new acpJob_default(
          this,
          job.id,
          job.clientAddress,
          job.providerAddress,
          job.evaluatorAddress,
          job.price,
          job.priceTokenAddress,
          job.memos.map((memo) => {
            return new acpMemo_default(
              this.contractClientByAddress(job.contractAddress),
              memo.id,
              memo.memoType,
              memo.content,
              memo.nextPhase,
              memo.status,
              memo.senderAddress,
              memo.signedReason,
              memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
              memo.payableDetails,
              memo.txHash,
              memo.signedTxHash
            );
          }),
          job.phase,
          job.context,
          job.contractAddress,
          job.netPayableAmount
        );
      });
    } catch (error) {
      throw new acpError_default("Failed to get cancelled jobs", error);
    }
  }
  async getJobById(jobId) {
    let url = `${this.acpUrl}/api/jobs/${jobId}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.acpContractClient.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      const job = data.data;
      if (!job) {
        return;
      }
      return new acpJob_default(
        this,
        job.id,
        job.clientAddress,
        job.providerAddress,
        job.evaluatorAddress,
        job.price,
        job.priceTokenAddress,
        job.memos.map((memo) => {
          return new acpMemo_default(
            this.contractClientByAddress(job.contractAddress),
            memo.id,
            memo.memoType,
            memo.content,
            memo.nextPhase,
            memo.status,
            memo.senderAddress,
            memo.signedReason,
            memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
            memo.payableDetails,
            memo.txHash,
            memo.signedTxHash
          );
        }),
        job.phase,
        job.context,
        job.contractAddress,
        job.netPayableAmount
      );
    } catch (error) {
      throw new acpError_default("Failed to get job by id", error);
    }
  }
  async getMemoById(jobId, memoId) {
    let url = `${this.acpUrl}/api/jobs/${jobId}/memos/${memoId}`;
    try {
      const response = await fetch(url, {
        headers: {
          "wallet-address": this.walletAddress
        }
      });
      const data = await response.json();
      if (data.error) {
        throw new acpError_default(data.error.message);
      }
      const memo = data.data;
      if (!memo) {
        return;
      }
      return new acpMemo_default(
        this.contractClientByAddress(memo.contractAddress),
        memo.id,
        memo.memoType,
        memo.content,
        memo.nextPhase,
        memo.status,
        memo.senderAddress,
        memo.signedReason,
        memo.expiry ? new Date(parseInt(memo.expiry) * 1e3) : void 0,
        memo.payableDetails,
        memo.txHash,
        memo.signedTxHash
      );
    } catch (error) {
      throw new acpError_default("Failed to get memo by id", error);
    }
  }
  async getAgent(walletAddress) {
    const url = `${this.acpUrl}/api/agents?filters[walletAddress]=${walletAddress}`;
    const response = await fetch(url);
    const data = await response.json();
    const agents = data.data || [];
    if (agents.length === 0) {
      return;
    }
    return agents[0];
  }
  async getAccountByJobId(jobId, acpContractClient) {
    try {
      const url = `${this.acpUrl}/api/accounts/job/${jobId}`;
      const response = await fetch(url);
      const data = await response.json();
      if (!data.data) {
        return null;
      }
      return new AcpAccount(
        acpContractClient || this.contractClients[0],
        data.data.id,
        data.data.clientAddress,
        data.data.providerAddress,
        data.data.metadata
      );
    } catch (error) {
      throw new acpError_default("Failed to get account by job id", error);
    }
  }
  async getByClientAndProvider(clientAddress, providerAddress, acpContractClient) {
    try {
      const url = `${this.acpUrl}/api/accounts/client/${clientAddress}/provider/${providerAddress}`;
      const response = await fetch(url);
      const data = await response.json();
      if (!data.data) {
        return null;
      }
      return new AcpAccount(
        acpContractClient || this.contractClients[0],
        data.data.id,
        data.data.clientAddress,
        data.data.providerAddress,
        data.data.metadata
      );
    } catch (error) {
      throw new acpError_default("Failed to get account by client and provider", error);
    }
  }
};
var acpClient_default = AcpClient;

// src/contractClients/acpContractClient.ts
import { LocalAccountSigner } from "@aa-sdk/core";
import { alchemy } from "@account-kit/infra";
import {
  createModularAccountV2Client
} from "@account-kit/smart-contracts";
import { decodeEventLog, encodeFunctionData as encodeFunctionData3 } from "viem";

// src/acpX402.ts
import {
  erc20Abi as erc20Abi3
} from "viem";
import { randomBytes } from "crypto";
var AcpX402 = class {
  constructor(config, sessionKeyClient, publicClient) {
    this.config = config;
    this.sessionKeyClient = sessionKeyClient;
    this.publicClient = publicClient;
    this.config = config;
    this.sessionKeyClient = sessionKeyClient;
    this.publicClient = publicClient;
  }
  async signUpdateJobNonceMessage(jobId, nonce) {
    const message = `${jobId}-${nonce}`;
    const signature = await this.sessionKeyClient.account.getSigner().signMessage(message);
    return signature;
  }
  async updateJobNonce(jobId, nonce) {
    try {
      const apiUrl = `${this.config.acpUrl}/api/jobs/${jobId}/x402-nonce`;
      const signature = await this.signUpdateJobNonceMessage(jobId, nonce);
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "x-signature": signature,
          "x-nonce": nonce,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          data: {
            nonce
          }
        })
      });
      if (!response.ok) {
        throw new acpError_default(
          "Failed to update job X402 nonce",
          response.statusText
        );
      }
      const acpJob = await response.json();
      return acpJob;
    } catch (error) {
      throw new acpError_default("Failed to update job X402 nonce", error);
    }
  }
  async generatePayment(payableRequest, requirements) {
    try {
      const USDC_CONTRACT = this.config.baseFare.contractAddress;
      const timeNow = Math.floor(Date.now() / 1e3);
      const validAfter = timeNow.toString();
      const validBefore = (timeNow + requirements.accepts[0].maxTimeoutSeconds).toString();
      const [tokenName, tokenVersion] = await this.publicClient.multicall({
        contracts: [
          {
            address: USDC_CONTRACT,
            abi: erc20Abi3,
            functionName: "name"
          },
          {
            address: USDC_CONTRACT,
            abi: fiatTokenV2Abi_default,
            functionName: "version"
          }
        ]
      });
      const nonce = `0x${randomBytes(32).toString("hex")}`;
      const message = {
        from: this.sessionKeyClient.account.address,
        to: payableRequest.to,
        value: payableRequest.value.toString(),
        validAfter: validAfter.toString(),
        validBefore: validBefore.toString(),
        nonce
      };
      const typedData = {
        types: {
          TransferWithAuthorization: X402AuthorizationTypes
        },
        domain: {
          name: tokenName.result,
          version: tokenVersion.result,
          chainId: this.config.chain.id,
          verifyingContract: USDC_CONTRACT
        },
        primaryType: "TransferWithAuthorization",
        message
      };
      const signature = await this.sessionKeyClient.signTypedData({
        typedData
      });
      const payload = {
        x402Version: requirements.x402Version,
        scheme: requirements.accepts[0].scheme,
        network: requirements.accepts[0].network,
        payload: {
          signature,
          authorization: message
        }
      };
      const encodedPayment = safeBase64Encode(JSON.stringify(payload));
      return {
        encodedPayment,
        signature,
        message
      };
    } catch (error) {
      throw new acpError_default("Failed to generate X402 payment", error);
    }
  }
  async performRequest(url, version2, budget, signature) {
    const baseUrl = this.config.x402Config?.url;
    if (!baseUrl) throw new acpError_default("X402 URL not configured");
    try {
      const headers = {};
      if (signature) headers["x-payment"] = signature;
      if (budget) headers["x-budget"] = budget.toString();
      headers["x-acp-version"] = version2;
      const res = await fetch(`${baseUrl}${url}`, { method: "GET", headers });
      const data = await res.json();
      if (!res.ok && res.status !== HTTP_STATUS_CODES.PAYMENT_REQUIRED) {
        throw new acpError_default(
          "Invalid response status code for X402 request",
          data
        );
      }
      return {
        isPaymentRequired: res.status === HTTP_STATUS_CODES.PAYMENT_REQUIRED,
        data
      };
    } catch (error) {
      throw new acpError_default("Failed to perform X402 request", error);
    }
  }
};

// src/contractClients/acpContractClient.ts
var AcpContractClient = class _AcpContractClient extends baseAcpContractClient_default {
  constructor(agentWalletAddress, config = baseAcpConfig) {
    super(agentWalletAddress, config);
    this.PRIORITY_FEE_MULTIPLIER = 2;
    this.MAX_FEE_PER_GAS = 2e7;
    this.MAX_PRIORITY_FEE_PER_GAS = 21e6;
  }
  static async build(walletPrivateKey, sessionEntityKeyId, agentWalletAddress, config = baseAcpConfig) {
    const acpContractClient = new _AcpContractClient(
      agentWalletAddress,
      config
    );
    await acpContractClient.init(walletPrivateKey, sessionEntityKeyId);
    return acpContractClient;
  }
  async init(privateKey, sessionEntityKeyId) {
    const sessionKeySigner = LocalAccountSigner.privateKeyToAccountSigner(privateKey);
    this._sessionKeyClient = await createModularAccountV2Client({
      chain: this.chain,
      transport: alchemy({
        rpcUrl: this.config.alchemyRpcUrl
      }),
      signer: sessionKeySigner,
      policyId: "186aaa4a-5f57-4156-83fb-e456365a8820",
      accountAddress: this.agentWalletAddress,
      signerEntity: {
        entityId: sessionEntityKeyId,
        isGlobalValidation: true
      }
    });
    this._acpX402 = new AcpX402(
      this.config,
      this.sessionKeyClient,
      this.publicClient
    );
    const account = this.sessionKeyClient.account;
    const sessionSignerAddress = await account.getSigner().getAddress();
    if (!await account.isAccountDeployed()) {
      throw new acpError_default(
        `ACP Contract Client validation failed: agent account ${this.agentWalletAddress} is not deployed on-chain`
      );
    }
    await this.validateSessionKeyOnChain(sessionSignerAddress, sessionEntityKeyId);
    console.log("Connected to ACP:", {
      agentWalletAddress: this.agentWalletAddress,
      whitelistedWalletAddress: sessionSignerAddress,
      entityId: sessionEntityKeyId
    });
  }
  getRandomNonce(bits = 152) {
    const bytes = bits / 8;
    const array = new Uint8Array(bytes);
    crypto.getRandomValues(array);
    let hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join(
      ""
    );
    return BigInt("0x" + hex);
  }
  get sessionKeyClient() {
    if (!this._sessionKeyClient) {
      throw new acpError_default("Session key client not initialized");
    }
    return this._sessionKeyClient;
  }
  get acpX402() {
    if (!this._acpX402) {
      throw new acpError_default("ACP X402 not initialized");
    }
    return this._acpX402;
  }
  async calculateGasFees() {
    const finalMaxFeePerGas = BigInt(this.MAX_FEE_PER_GAS) + BigInt(this.MAX_PRIORITY_FEE_PER_GAS) * BigInt(Math.max(0, this.PRIORITY_FEE_MULTIPLIER - 1));
    return finalMaxFeePerGas;
  }
  async handleOperation(operations) {
    const payload = {
      uo: operations.map((op) => ({
        target: op.contractAddress,
        data: op.data,
        value: op.value
      })),
      overrides: {
        nonceKey: this.getRandomNonce()
      }
    };
    let retries = this.config.maxRetries;
    let finalError;
    while (retries > 0) {
      try {
        if (this.config.maxRetries > retries) {
          const gasFees = await this.calculateGasFees();
          payload["overrides"] = {
            maxFeePerGas: `0x${gasFees.toString(16)}`
          };
        }
        const { hash } = await this.sessionKeyClient.sendUserOperation(payload);
        const txnHash = await this.sessionKeyClient.waitForUserOperationTransaction({
          hash
        });
        return { userOpHash: hash, txnHash };
      } catch (error) {
        retries -= 1;
        if (retries === 0) {
          finalError = error;
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3 * retries));
      }
    }
    throw new acpError_default(`Failed to send user operation`, finalError);
  }
  async getJobId(createJobUserOpHash, clientAddress, providerAddress) {
    const result = await this.sessionKeyClient.getUserOperationReceipt(createJobUserOpHash);
    if (!result) {
      throw new acpError_default("Failed to get user operation receipt");
    }
    const contractLogs = result.logs.filter((log) => {
      return log.address.toLowerCase() === this.contractAddress.toLowerCase();
    }).map(
      (log) => decodeEventLog({
        abi: this.abi,
        data: log.data,
        topics: log.topics
      })
    );
    const createdJobEvent = contractLogs.find(
      (log) => log.eventName === "JobCreated" && log.args.client.toLowerCase() === clientAddress.toLowerCase() && log.args.provider.toLowerCase() === providerAddress.toLowerCase()
    );
    if (!createdJobEvent) {
      throw new acpError_default("Failed to find created job event");
    }
    return Number(createdJobEvent.args.jobId);
  }
  createJob(providerAddress, evaluatorAddress, expireAt, paymentTokenAddress, budgetBaseUnit, metadata, isX402Job) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: isX402Job ? "createJobWithX402" : "createJob",
        args: [
          providerAddress,
          evaluatorAddress,
          Math.floor(expireAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create job", error);
    }
  }
  setBudgetWithPaymentToken(jobId, budgetBaseUnit, paymentTokenAddress = this.config.baseFare.contractAddress) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: "setBudgetWithPaymentToken",
        args: [jobId, budgetBaseUnit, paymentTokenAddress]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to set budget", error);
    }
  }
  createPayableMemo(jobId, content, amountBaseUnit, recipient, feeAmountBaseUnit, feeType, nextPhase, type, expiredAt, token = this.config.baseFare.contractAddress, secured = true) {
    try {
      const data = encodeFunctionData3({
        abi: this.abi,
        functionName: "createPayableMemo",
        args: [
          jobId,
          content,
          token,
          amountBaseUnit,
          recipient,
          feeAmountBaseUnit,
          feeType,
          type,
          nextPhase,
          Math.floor(expiredAt.getTime() / 1e3)
        ]
      });
      const payload = {
        data,
        contractAddress: this.contractAddress
      };
      return payload;
    } catch (error) {
      throw new acpError_default("Failed to create payable memo", error);
    }
  }
  createJobWithAccount(accountId, evaluatorAddress, budgetBaseUnit, paymentTokenAddress, expiredAt, isX402Job) {
    throw new acpError_default("Not Supported");
  }
  updateAccountMetadata(accountId, metadata) {
    throw new acpError_default("Not Supported");
  }
  async updateJobX402Nonce(jobId, nonce) {
    return await this.acpX402.updateJobNonce(jobId, nonce);
  }
  async generateX402Payment(payableRequest, requirements) {
    return await this.acpX402.generatePayment(payableRequest, requirements);
  }
  async performX402Request(url, version2, budget, signature) {
    return await this.acpX402.performRequest(url, version2, budget, signature);
  }
  getAcpVersion() {
    return "1";
  }
};
var acpContractClient_default = AcpContractClient;

// src/contractClients/acpContractClientV2.ts
import { LocalAccountSigner as LocalAccountSigner2 } from "@aa-sdk/core";
import { alchemy as alchemy2 } from "@account-kit/infra";
import {
  createModularAccountV2Client as createModularAccountV2Client2
} from "@account-kit/smart-contracts";
import { createPublicClient as createPublicClient4, decodeEventLog as decodeEventLog2, http as http3 } from "viem";

// src/abis/jobManagerAbi.ts
var JOB_MANAGER_ABI = [
  { inputs: [], stateMutability: "nonpayable", type: "constructor" },
  { inputs: [], name: "AccessControlBadConfirmation", type: "error" },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "bytes32", name: "neededRole", type: "bytes32" }
    ],
    name: "AccessControlUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "implementation", type: "address" }
    ],
    name: "ERC1967InvalidImplementation",
    type: "error"
  },
  { inputs: [], name: "ERC1967NonPayable", type: "error" },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "InvalidInitialization", type: "error" },
  { inputs: [], name: "NotInitializing", type: "error" },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  { inputs: [], name: "UUPSUnauthorizedCallContext", type: "error" },
  {
    inputs: [{ internalType: "bytes32", name: "slot", type: "bytes32" }],
    name: "UUPSUnsupportedProxiableUUID",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "BudgetSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint64",
        name: "version",
        type: "uint64"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "accountId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "client",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "provider",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "evaluator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "expiredAt",
        type: "uint256"
      }
    ],
    name: "JobCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "paymentToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newBudget",
        type: "uint256"
      }
    ],
    name: "JobPaymentTokenSet",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "enum ACPTypes.JobPhase",
        name: "oldPhase",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "enum ACPTypes.JobPhase",
        name: "newPhase",
        type: "uint8"
      }
    ],
    name: "JobPhaseUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "bytes32",
        name: "previousAdminRole",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "newAdminRole",
        type: "bytes32"
      }
    ],
    name: "RoleAdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleGranted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "bytes32", name: "role", type: "bytes32" },
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "RoleRevoked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "jobId",
        type: "uint256"
      }
    ],
    name: "X402PaymentReceived",
    type: "event"
  },
  {
    inputs: [],
    name: "ACP_CONTRACT_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "DEFAULT_ADMIN_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MEMO_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_INTERFACE_VERSION",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "X402_MANAGER_ROLE",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "accountJobs",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acpContract",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "address", name: "user", type: "address" }
    ],
    name: "canModifyJob",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "confirmX402PaymentReceived",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJob",
    outputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      },
      { internalType: "uint256", name: "expiredAt", type: "uint256" }
    ],
    name: "createJobWithX402",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getAccountJobs",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job[]",
        name: "jobArray",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "getJob",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes32", name: "role", type: "bytes32" }],
    name: "getRoleAdmin",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "assignee", type: "address" },
      { internalType: "uint256", name: "offset", type: "uint256" },
      { internalType: "uint256", name: "limit", type: "uint256" }
    ],
    name: "getUserJobs",
    outputs: [
      {
        components: [
          { internalType: "uint256", name: "id", type: "uint256" },
          { internalType: "uint256", name: "accountId", type: "uint256" },
          { internalType: "address", name: "client", type: "address" },
          { internalType: "address", name: "provider", type: "address" },
          { internalType: "address", name: "evaluator", type: "address" },
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "uint256", name: "budget", type: "uint256" },
          {
            internalType: "contract IERC20",
            name: "jobPaymentToken",
            type: "address"
          },
          {
            internalType: "enum ACPTypes.JobPhase",
            name: "phase",
            type: "uint8"
          },
          { internalType: "uint256", name: "expiredAt", type: "uint256" },
          { internalType: "uint256", name: "createdAt", type: "uint256" },
          { internalType: "uint256", name: "memoCount", type: "uint256" },
          { internalType: "string", name: "metadata", type: "string" },
          { internalType: "uint256", name: "amountClaimed", type: "uint256" }
        ],
        internalType: "struct ACPTypes.Job[]",
        name: "jobArray",
        type: "tuple[]"
      },
      { internalType: "uint256", name: "total", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "getX402PaymentDetails",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "isX402", type: "bool" },
          { internalType: "bool", name: "isBudgetReceived", type: "bool" }
        ],
        internalType: "struct ACPTypes.X402PaymentDetail",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "grantRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "hasRole",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "incrementMemoCount",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "acpContract_", type: "address" }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "jobCounter",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "jobs",
    outputs: [
      { internalType: "uint256", name: "id", type: "uint256" },
      { internalType: "uint256", name: "accountId", type: "uint256" },
      { internalType: "address", name: "client", type: "address" },
      { internalType: "address", name: "provider", type: "address" },
      { internalType: "address", name: "evaluator", type: "address" },
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "jobPaymentToken",
        type: "address"
      },
      { internalType: "enum ACPTypes.JobPhase", name: "phase", type: "uint8" },
      { internalType: "uint256", name: "expiredAt", type: "uint256" },
      { internalType: "uint256", name: "createdAt", type: "uint256" },
      { internalType: "uint256", name: "memoCount", type: "uint256" },
      { internalType: "string", name: "metadata", type: "string" },
      { internalType: "uint256", name: "amountClaimed", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "callerConfirmation", type: "address" }
    ],
    name: "renounceRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bytes32", name: "role", type: "bytes32" },
      { internalType: "address", name: "account", type: "address" }
    ],
    name: "revokeRole",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      { internalType: "uint256", name: "budget", type: "uint256" },
      {
        internalType: "contract IERC20",
        name: "paymentToken",
        type: "address"
      }
    ],
    name: "setJobBudget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "x402PaymentTokenAddress",
        type: "address"
      }
    ],
    name: "setX402PaymentToken",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "acpContract_", type: "address" }
    ],
    name: "updateContracts",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "jobId", type: "uint256" },
      {
        internalType: "enum ACPTypes.JobPhase",
        name: "newPhase",
        type: "uint8"
      }
    ],
    name: "updateJobPhase",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "newImplementation", type: "address" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    name: "userJobs",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "jobId", type: "uint256" }],
    name: "x402PaymentDetails",
    outputs: [
      { internalType: "bool", name: "isX402", type: "bool" },
      { internalType: "bool", name: "isBudgetReceived", type: "bool" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "x402PaymentToken",
    outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  }
];
var jobManagerAbi_default = JOB_MANAGER_ABI;

// src/contractClients/acpContractClientV2.ts
var AcpContractClientV2 = class _AcpContractClientV2 extends baseAcpContractClient_default {
  constructor(jobManagerAddress, memoManagerAddress, accountManagerAddress, agentWalletAddress, config = baseAcpConfigV2) {
    super(agentWalletAddress, config);
    this.jobManagerAddress = jobManagerAddress;
    this.memoManagerAddress = memoManagerAddress;
    this.accountManagerAddress = accountManagerAddress;
    this.PRIORITY_FEE_MULTIPLIER = 2;
    this.MAX_FEE_PER_GAS = 2e7;
    this.MAX_PRIORITY_FEE_PER_GAS = 21e6;
  }
  static async build(walletPrivateKey, sessionEntityKeyId, agentWalletAddress, config = baseAcpConfigV2) {
    const publicClient = createPublicClient4({
      chain: config.chain,
      transport: http3(config.rpcEndpoint)
    });
    const [jobManagerAddress, memoManagerAddress, accountManagerAddress] = await publicClient.multicall({
      contracts: [
        {
          address: config.contractAddress,
          abi: config.abi,
          functionName: "jobManager"
        },
        {
          address: config.contractAddress,
          abi: config.abi,
          functionName: "memoManager"
        },
        {
          address: config.contractAddress,
          abi: config.abi,
          functionName: "accountManager"
        }
      ]
    });
    if (!jobManagerAddress || !memoManagerAddress || !accountManagerAddress) {
      throw new acpError_default(
        "Failed to get job manager, memo manager, or account manager address"
      );
    }
    const acpContractClient = new _AcpContractClientV2(
      jobManagerAddress.result,
      memoManagerAddress.result,
      accountManagerAddress.result,
      agentWalletAddress,
      config
    );
    await acpContractClient.init(walletPrivateKey, sessionEntityKeyId);
    return acpContractClient;
  }
  async init(privateKey, sessionEntityKeyId) {
    const sessionKeySigner = LocalAccountSigner2.privateKeyToAccountSigner(privateKey);
    this._sessionKeyClient = await createModularAccountV2Client2({
      chain: this.chain,
      transport: alchemy2({
        rpcUrl: this.config.alchemyRpcUrl
      }),
      signer: sessionKeySigner,
      policyId: "186aaa4a-5f57-4156-83fb-e456365a8820",
      accountAddress: this.agentWalletAddress,
      signerEntity: {
        entityId: sessionEntityKeyId,
        isGlobalValidation: true
      }
    });
    this._acpX402 = new AcpX402(
      this.config,
      this.sessionKeyClient,
      this.publicClient
    );
    const account = this.sessionKeyClient.account;
    const sessionSignerAddress = await account.getSigner().getAddress();
    if (!await account.isAccountDeployed()) {
      throw new acpError_default(
        `ACP Contract Client validation failed: agent account ${this.agentWalletAddress} is not deployed on-chain`
      );
    }
    await this.validateSessionKeyOnChain(sessionSignerAddress, sessionEntityKeyId);
    console.log("Connected to ACP:", {
      agentWalletAddress: this.agentWalletAddress,
      whitelistedWalletAddress: sessionSignerAddress,
      entityId: sessionEntityKeyId
    });
  }
  getRandomNonce(bits = 152) {
    const bytes = bits / 8;
    const array = new Uint8Array(bytes);
    crypto.getRandomValues(array);
    let hex = Array.from(array, (b) => b.toString(16).padStart(2, "0")).join(
      ""
    );
    return BigInt("0x" + hex);
  }
  get sessionKeyClient() {
    if (!this._sessionKeyClient) {
      throw new acpError_default("Session key client not initialized");
    }
    return this._sessionKeyClient;
  }
  get acpX402() {
    if (!this._acpX402) {
      throw new acpError_default("ACP X402 not initialized");
    }
    return this._acpX402;
  }
  async calculateGasFees() {
    const finalMaxFeePerGas = BigInt(this.MAX_FEE_PER_GAS) + BigInt(this.MAX_PRIORITY_FEE_PER_GAS) * BigInt(Math.max(0, this.PRIORITY_FEE_MULTIPLIER - 1));
    return finalMaxFeePerGas;
  }
  async handleOperation(operations) {
    const payload = {
      uo: operations.map((operation) => ({
        target: operation.contractAddress,
        data: operation.data,
        value: operation.value
      })),
      overrides: {
        nonceKey: this.getRandomNonce()
      }
    };
    let retries = this.config.maxRetries;
    let finalError;
    while (retries > 0) {
      try {
        if (this.config.maxRetries > retries) {
          const gasFees = await this.calculateGasFees();
          payload["overrides"] = {
            maxFeePerGas: `0x${gasFees.toString(16)}`
          };
        }
        const { hash } = await this.sessionKeyClient.sendUserOperation(payload);
        const txnHash = await this.sessionKeyClient.waitForUserOperationTransaction({
          hash,
          tag: "pending",
          retries: {
            intervalMs: 200,
            multiplier: 1.1,
            maxRetries: 10
          }
        });
        return { userOpHash: hash, txnHash };
      } catch (error) {
        retries -= 1;
        if (retries === 0) {
          finalError = error;
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, 2e3 * retries));
      }
    }
    throw new acpError_default(`Failed to send user operation`, finalError);
  }
  async getJobId(createJobUserOpHash, clientAddress, providerAddress) {
    const result = await this.sessionKeyClient.getUserOperationReceipt(
      createJobUserOpHash,
      "pending"
    );
    if (!result) {
      throw new acpError_default("Failed to get user operation receipt");
    }
    const contractLogs = result.logs.filter((log) => {
      return log.address.toLowerCase() === this.jobManagerAddress.toLowerCase();
    }).map(
      (log) => decodeEventLog2({
        abi: jobManagerAbi_default,
        data: log.data,
        topics: log.topics
      })
    );
    const createdJobEvent = contractLogs.find(
      (log) => log.eventName === "JobCreated" && log.args.client.toLowerCase() === clientAddress.toLowerCase() && log.args.provider.toLowerCase() === providerAddress.toLowerCase()
    );
    if (!createdJobEvent) {
      throw new acpError_default("Failed to find created job event");
    }
    return Number(createdJobEvent.args.jobId);
  }
  async updateJobX402Nonce(jobId, nonce) {
    return await this.acpX402.updateJobNonce(jobId, nonce);
  }
  async generateX402Payment(payableRequest, requirements) {
    return await this.acpX402.generatePayment(payableRequest, requirements);
  }
  async performX402Request(url, version2, budget, signature) {
    return await this.acpX402.performRequest(url, version2, budget, signature);
  }
  async getX402PaymentDetails(jobId) {
    try {
      const result = await this.publicClient.readContract({
        address: this.jobManagerAddress,
        abi: jobManagerAbi_default,
        functionName: "x402PaymentDetails",
        args: [BigInt(jobId)]
      });
      return {
        isX402: result[0],
        isBudgetReceived: result[1]
      };
    } catch (error) {
      throw new acpError_default("Failed to get X402 payment details", error);
    }
  }
  getAcpVersion() {
    return "2";
  }
};
var acpContractClientV2_default = AcpContractClientV2;

// src/index.ts
var index_default = acpClient_default;
export {
  acpAbi_default as ACP_ABI,
  AcpAgentSort,
  acpContractClient_default as AcpContractClient,
  acpContractClientV2_default as AcpContractClientV2,
  AcpContractConfig2 as AcpContractConfig,
  acpError_default as AcpError,
  AcpGraduationStatus,
  acpJob_default as AcpJob,
  AcpJobPhases,
  acpMemo_default as AcpMemo,
  AcpMemoStatus,
  AcpOnlineStatus,
  baseAcpContractClient_default as BaseAcpContractClient,
  Fare,
  FareAmount,
  FareBigInt,
  MemoType,
  PayloadType,
  PositionDirection,
  baseAcpConfig,
  baseAcpConfigV2,
  baseAcpX402Config,
  baseAcpX402ConfigV2,
  baseSepoliaAcpConfig,
  baseSepoliaAcpConfigV2,
  index_default as default,
  ethFare,
  preparePayload,
  wethFare
};
